<section>
    <h1>Promises <br>& <br>Async / Await</h1>
</section>
<section>
    <h2>Szenario</h2>
    <p class="fragment">
        Eine Anwendung ruft Daten ab, verarbeitet diese und stellt diese schön formatiert dar.
    </p>
    <p class="fragment">
        Problem: Wann werden die Daten von der API zurückgegeben?
    </p>
    <p class="fragment">
        Antwort: Wenn die API die Daten zurückgibt. Wir wissen es nicht!
    </p>
    <p class="fragment">
        Lösung: Wir warten auf die Rückgabe der Daten -> Promises
    </p>
    <aside class="notes">
        Eine Website lädt Daten von einer API und verarbeitet und formatiert diese Daten um sie dem
        Nutzer anzuzeigen.
        Wenn wir versuchen die Daten zu verarbeiten bevor sie von der API zurückgegeben wurden, bekommen wir
        entweder einen Fehler oder eine leere Website.
        Wenn wir allerdings ein Promise verwenden, können wir sicherstellen, dass die API Daten erst verarbeitet
        werden, wenn der API Aufruf erfolgreich Daten zurückgegeben hat.
    </aside>
</section>
<section>
    <p>
        Promise<br>
        =
        <br>
        mögliches Ergebnis einer asynchronen Operation
    </p>
    <aside class="notes">
        wie ein Platzhalter = Objekt an das man Callbacks anhängen kann<br>
        Promises erlauben uns auf die Ausführung eines bestimmten Codesteils zu warten, bevor ein anderer Teil
        ausgeführt wird.
    </aside>
</section>
<section>
    <pre><code data-trim data-noescape>
    function success(result) {
        console.log("Audio file ready at URL: " + result);
    }
    
    function failure(error) {
        console.log("Error generating audio file: " + error);
    }
    
    // Without promise
    createAudioFileAsync(audioSettings, success, failure);

    // With promise
    createAudioFileAsync(audioSettings).then(success, failure);
    </code></pre>
    <p class="fragment">
        <code>then()</code> wird erst ausgeführt, wenn die Funktion <code>createAudioFileAsync</code> fertig ausgeführt ist
    </p>
    <aside class="notes">
        <ul>
            <li>Callbacks, die per then() an ein Promise gehängt werden, sogar nach dem Erfolgs- oder Fehlerfall werden ausgeführt.</li>
            <li>mehrere then() können hintereinander gehängt werden -> Sie werden in der Reihenfolge hintereinander ausgeführt</li>
        </ul>
    </aside>
</section>
<section>
    <h2>Promise Chaining</h2>
    <pre><code data-trim data-noescape>
    promiseFunction()
        .then(success1, failure1)
        .then(success2, failure2)
        .catch(failureCallback);
    </code></pre>
    <p>
        <h3>Wichtig</h3>
        <ul>
            <li>Immer ein Ergebnis zurückgeben, sonst bekommt der Callback das Ergebnis des vorherigen Promises nicht</li>
            <li>Wenn ein <code>then()</code> einen Fehler wirft, stoppt die Promise Chain und schaut, ob es weiter unten ein catch gibt</li>
        </ul>
    </p>
    <aside class="notes">
        Auführung: 1. promiseFunction 2. success1()/failure1() 3. success2()/failure2()
    </aside>
</section>
<section>
    <h2>Promise erstellen</h2>
    <pre><code data-trim data-noescape>
    new Promise( /* executor */ function(resolve, reject) { ... } );
    </code></pre>
    <p>
        Ein Promise erstellen, z.B. um eine alte API zu wrappen:
    </p>
    <pre><code data-trim data-noescape>
    const wait = ms => new Promise(resolve => setTimeout(resolve, ms));
    // alternative: Promise.resolve(setTimeout(resolve, ms));
    wait(10000)
        .then(() => saySomething("10 seconds"))
        .catch(failureCallback);
    </code></pre>
    <aside class="notes">
        Eine Funktion mit den Argumenten resolve und reject wird übergeben. Die Executor-Funktion wird sofort von der Promise Implementierung ausgeführt.
        Die Executor-Funktion initiiert asynchrone Arbeit und dann, wenn sie fertig ist, ruft sie die resolve oder reject-Funktion auf. Wenn ein Fehler in der Executor-Funktion auftritt, wird der Promise verworfen und der Rückgabewert verworfen.
    </aside>
</section>
<section>
    <pre><code data-trim data-noescape>
    // callback hell
    doSomething(function(result) {
        doSomethingElse(result, function(newResult) {
            doThirdThing(newResult, function(finalResult) {
                console.log('Got the final result: ' + finalResult);
            }, failureCallback);
        }, failureCallback);
    }, failureCallback);
    </code></pre>
</section>
<section>
    <pre><code data-trim data-noescape>
    // promise chain
    doSomething()
    .then(function(result) {
        return doSomethingElse(result);
    })
    .then(function(newResult) {
        return doThirdThing(newResult);
    })
    .then(function(finalResult) {
        console.log('Got the final result: ' + finalResult);
    })
    .catch(failureCallback);
    </code></pre>
</section>
<section>
    <pre><code data-trim data-noescape>
    // promise chain with arrow functions
    doSomething()
        .then(result => doSomethingElse(result))
        .then(newResult => doThirdThing(newResult))
        .then(finalResult => {
            console.log(`Got the final result: ${finalResult}`);
        })
        .catch(failureCallback);
    </code></pre>
</section>
<section>
    <h2>Warte auf uns!</h2>
    <pre><code data-trim data-noescape class="typescript">
    let p1 = Promise.resolve(3);
    let p2 = 1337;
    let p3 = new Promise((resolve, reject) => {
        setTimeout(resolve, 100, 'foo');
    });
    
    Promise.all([p1, p2, p3])
    .then(values => {
        console.log(values);
    });
    </code></pre>
    <pre class="fragment"><code data-trim data-noescape class="typescript">
    // [3, 1337, "foo"]
    </code></pre>
    <aside class="notes">
        <ul>
            <li>Promises werden parallel verarbeitet.</li>
            <li>Gibt ein Promise zurück, das aufgelöst wird, wenn alle Argumente aufgelöst oder verworfen wurden oder wenn kein Argument einen Promise enthält. Es wird mit dem ersten verworfenen Grund verworfen.</li>
        </ul>
    </aside>
</section>
<section>
    <h2>Erster gewinnt!</h2>
    <pre><code data-trim data-noescape class="typescript">
    let promise1 = new Promise((resolve, reject) => {
        setTimeout(resolve, 500, 'one');
    });
    
    let promise2 = new Promise((resolve, reject) => {
        setTimeout(resolve, 100, 'two');
    });
    
    Promise.race([promise1, promise2]).then(function(value) {
        console.log(value);
    });
    </code></pre>
    <pre class="fragment"><code data-trim data-noescape class="typescript">
    // Both resolve, but promise2 is faster
    // expected output: "two"
    </code></pre>
    <aside class="notes">
        <ul>
            <li>Promises werden parallel verarbeitet.</li>
        </ul>
    </aside>
</section>
<section>
    <h2>Do's</h2>
    <ul>
        <li>Funktionen richtig miteinander verketten: Immer das erstellte Promise zurückgeben.</li>
        <li>Promises nur verketten und nicht verschachteln.</li>
        <li>Eine Promise Kette immer mit einem catch beenden</li>
    </ul>
</section>
<section>
    <h2>Timing</h2>
    <pre><code data-trim data-noescape class="typescript">
    Promise.resolve().then(() => console.log(2));
    console.log(1);
    </code></pre>
    <pre class="fragment"><code data-trim data-noescape class="typescript">
    // expected output:  1, 2
    </code></pre>
    <p class="fragment">
        Die übergebene Funktion wird auf die Microtask-Queue gelegt, d.h. die Funktion wird später ausgeführt, weil die Queue erst am Ende des aktuellen Laufs der JavaScript Event Loop abgearbeitet wird.
    </p>
</section>
<section>
    <h2>Quellen zu Promises</h2>
    <ul>
        <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">MDN Promise</a></li>
        <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises">MDN Using Promises</a></li>
    </ul>
</section>
<section>
    <h2>Übung Promise</h2>
    <p>Setze die Konsolenausgabe mit einem Promise um</p>
    <pre><code data-trim data-noescape class="typescript">
    // Konsolenausgabe
    Initial
    Do that
    Do this, no matter what happened before
    </code></pre>
    <ul>
        <li>Ausgabe "Initial" wird im erstelltem Promise geloggt</li>
        <li>Fehlerfall bei dem normalerweise "Do this" geloggt worden wäre, aber wegen des Fehlers "Do that" geloggt wird</li>
    </ul>
</section>
<section>
    <h2>Lösung Übung Promise</h2>
    <pre><code data-trim data-noescape class="typescript">
    new Promise((resolve, reject) => {
        console.log('Initial');
        resolve();
    })
    .then(() => {
        throw new Error('Something failed');
            
        console.log('Do this');
    })
    .catch(() => {
        console.log('Do that');
    })
    .then(() => {
        console.log('Do this, no matter what happened before');
    });
    </code></pre>
</section>
<section>
    <h3>Async / Await</h3>
    <ul>
        <li>Einführung mit ES2017</li>
        <li>Eine <code>async</code> Funktion Deklaration definiert eine asynchrone Funktion. Sie kann eine <code>await</code> Expression enthalten, die die Ausführung der <code>async</code> Funktion unterbricht und auf die Auflösung des Promise wartet und dann erst die <code>async</code> Funktion weiter ausführt.</li>
        <li>Mit <code>async</code>/<code>await</code> können wir Promises im Programmablauf synchron verwenden.</li>
    </ul>
</section>
<section>
    <h2>Refactoring der Promise Chain mit einer async Function</h2>
    <pre><code data-trim data-noescape>
    async function foo() {
        try {
            const result = await doSomething();
            const newResult = await doSomeThingElse(result);
            const finalResult = await doThirdThing(newResult);
            console.log(`Got the final result: ${finalResult}`);
        } catch(error) {
            failureCallback(error);
        }
    }
    </code></pre>
    <aside class="notes">
        <code>await</code> Schlüsselwort ist nur in einer <code>async</code> Funktion valide.
    </aside>
</section>
<section>
    <h2>Quellen zu Async / Await</h2>
    <ul>
        <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">MDN Async Function</a></li>
    </ul>
</section>
<section>
    <h1>RxJS</h1>
    <!-- <p>
        5-10 wichtigsten Funktionen von RxJS:
        <ul>
            <li>pipe(map, map)</li>
            <li>map</li>
            <li>switchMap, mergeMap, concatMap</li>
            <li>filter</li>
            <li>from, of, timer, interval</li>
            <li>combineLatest</li>
            <li>merge, zip</li>
        </ul>
    </p> -->
</section>
<section>
    <h2>Was ist RxJS?</h2>
    <p>
        <ul>
            <li>Reactive Extensions für JavaScript</li>
            <li>Bibliothek für die Reaktive Programmierung unter Nutzung von Observables, die einem das Komponieren von asynchronem und auf Event basiertem Code erleichtert</li>
            <li>Verwendete Patterns: Observer Pattern, Iterator Pattern, Functional Programming with collections</li>
        </ul>
    </p>
    <aside class="notes">
        Wikipedia: 
    </aside>
</section>
<section>
    <h2>Reaktive Programmierung</h2>
    <p>
        Asynchrones Programmierparadigma, das sich um Datenströme und Weitergabe von Änderungen kümmert.
    </p>
    <aside class="notes">
        "Bei der Datenverarbeitung ist Reaktive Programmierung ein Programmierparadigma, das sich an Datenflüssen orientiert. In den zugeordneten Programmiersprachen sind statische oder dynamische Datenflüsse leicht auszudrücken. Das zugrunde liegende Ausführungsmodell propagiert Änderungen in den Datenflüssen automatisch. Ein gutes Beispiel für ein Programm, welches reaktiv arbeitet, ist Excel. Ändert man einen Wert in einer Zelle, dann ändert sich auch der Wert in der Summenzelle. Die Zelle, deren Wert geändert wurde, löst ein Event (eine Meldung) aus, den die Summen-Zelle empfängt und die dann eine Neukalkulation ausführt."
        Quelle: https://de.wikipedia.org/wiki/Reaktive_Programmierung
    </aside>
</section>
<section>
    <h2>Observer Pattern</h2>
    <ul>
        <li>Ein Objekt (Subject) verwaltet eine Liste abhängiger Strukturen (Observers) und benachrichtigt sie automatisch bei jeder Statusänderung des Objekts (publish-subscribe).</li>
        <li>Es wird zur Implementierung von verteilten Event Handling Systemen verwendet ("Event Driven" Software).</li>
    </ul>
    <aside class="notes">
        Quellen: https://en.wikipedia.org/wiki/Observer_pattern, https://de.wikipedia.org/wiki/Beobachter_(Entwurfsmuster)
    </aside>
</section>
<section>
    <h2>Iterator Pattern</h2>
    <p>
        Über einen Iterator kann auf die Elemente einer aggregierten Struktur sequenziell zugegriffen werden, ohne die Struktur zu enthüllen.
    </p>
    <aside class="notes">
        Ich kann über ein Array von Zahlen genauso iterieren, wie über ein Array von Objekten oder Strings. Der Iterator ist somit universell einsetzbar<br>
        Quelle: https://en.wikipedia.org/wiki/Iterator_pattern
    </aside>
</section>
<section>
    <h2>Was bietet mir RxJS?</h2>
    <p>
        <ul>
            <li>...existierenden Code asynchroner Operationen in Observables zu konvertieren</li>
            <li>...durch die Werte eines Streams zu iterieren</li>
            <li>...Werte auf verschiedene Typen zu mappen</li>
            <li>...Streams zu filtern</li>
            <li>...mehrere Streams miteinander zu verknüpfen</li>
        </ul>
    </p>
</section>
<section>
    <h2>Erstellen und Horchen</h2>
    <pre><code data-trim data-noescape>
    import { of } from "rxjs";

    function next(val: number) {
        console.log(`next: ${val}`);
    }
    function error() {
        console.log("error!");
    }
    function completed() {
        console.log("completed!");
    }
    
    of(1, 2, 3, 4).subscribe(next, error, completed);
    </code></pre>
</section>
<section>
    <h2>Hot & Cold Obervables (1)</h2>
    <h3>Cold Observable</h3>
    <ul>
        <li>The data producer is created by the observable itself</li>
        <li>Multiple subscribers: the whole data stream is re-emitted for each subscriber</li>
        <li>Always emits</li>
        <li>Making a cold observable hot using the <code>share</code> operator</li>
        <li>Examples: observables created using the <code>of</code>, <code>from</code>, <code>range</code>, <code>interval</code> and <code>timer</code> operators</li>
    </ul>
    <aside class="notes">
        multiple subscribers: Each subscriber becomes independent and gets its own stream of data<br>
        data is not being produced until the observable is subscribed to.
    </aside>
</section>
<section>
    <h2>Hot & Cold Obervables (2)</h2>
    <h3>Hot Observable</h3>
    <ul>
        <li>The data producer is outside of the observable itself</li>
        <li>These observables are closing over external data producers</li>
        <li>The data is being produced regardless of if there’s a subscriber or not.</li>
        <li>Examples: <code>fromEvent</code> operator for user events (clicks, mouse moves,…) or WebSocket events</li>
    </ul>
    <aside class="notes">
        If there’s no subscriber when the data is being produced, the data is simply lost.
    </aside>
</section>
<section>
    <h2>Operatoren</h2>
    <p>
        Operatoren nehmen Konfigurationsoptionen entgegen und geben eine Funktion zurück, die ein ursprüngliches Observable entgegennimmt.<br>
        Wenn diese zurückgegebene Funktion ausgeführt wird, überwacht der Operator die ausgegebenen Werte des ursprünglichen Obervables, transformiert sie und gibt ein neues Observable dieser transformierten Werte zurück.
    </p>
</section>
<section>
    <h2>Operator <code>map()</code></h2>
    <pre><code data-trim data-noescape>
    map(project: Function, thisArg?: any): Observable
    </code></pre>
    <p>
        Führt eine übergegebene Function (project) auf jedem vom ursprünglichen Observable ausgegebenen Wert aus und gibt die Ergebniswerte als neues Observable zurück.
    </p>
</section>
<section>
    <h2>Operator <code>filter()</code></h2>
    <pre><code data-trim data-noescape>
    filter(predicate: Function, thisArg?: any): Observable
    </code></pre>
    <p>
        Filtert die Elemente, die das ursprüngliche Observable ausgibt, und gibt nur die Elemente aus, die das spezifizierte Prädikat (predicate) erfüllen.
    </p>
</section>
<section>
    <h2>Operator <code>pipe()</code></h2>
    <pre><code data-trim data-noescape>
    pipe(functions: ...*): Observable
    </code></pre>
    <p>
        Verknüpfungsmöglichkeit von Operatoren.<br>
        Die Argumente der pipe-Funktion sind die Funktionen, die man verknüpfen will. Die Funktion gibt eine neue Funktion zurück, die, wenn sie ausgeführt wird, die verknüpften Funktionen als Sequenz zurückgibt.<br>
        Man könnte es auch Rezept (Set von Instruktionen, die die Werte produzieren, an denen man interessiert ist) nennen. Das Rezept selbst tut nichts, erst wenn man subscribe() darauf aufruft, wird das Rezept ausgeführt.
    </p>
</section>
<section>
    <h2>Operator <code>concat()</code></h2>
    <pre><code data-trim data-noescape>
    concat(observables: ...*): Observable
    </code></pre>
    <p>
        Erstellt ein Observable, das sequenziell alle Werte des ersten übergebenen Observables ausgibt und dann zum nächsten Observable weitergeht.
    </p>
</section>
<section>
    <h2>Operator <code>flatMap()</code> / <code>mergeMap()</code></h2>
    <pre><code data-trim data-noescape>
    flatMap(project: function: Observable, resultSelector: function: any, concurrent: number): Observable
    </code></pre>
    <p>
        Jeder Ursprungswert wird auf ein Observable projeziert, das im Ausgabe-Observable zusammengeführt wird.
    </p>
</section>
<section>
    <h2>Operator <code>catchError()</code></h2>
    <pre><code data-trim data-noescape>
    catchError(project: function): Observable
    </code></pre>
    <p>
        Fehler kontrolliert in einer Observable Sequenz behandeln.<br>
        <br>
        Achtung: Immer ein Observable zurückgeben, da es vom nächsten Schritt übernommen wird!
    </p>
</section>
<section>
    <h2>Operator <code>retry()</code> & <code>retryWhen()</code></h2>
    <pre><code class="typescript" data-trim data-noescape style="font-size: 20px">
    retry(count: number): Observable
    retryWhen(receives: (errors: Observable) => Observable, the: scheduler): Observable
    </code></pre>
    <p>
        If origin observable throws an error -> retry count times after throwing error or retryWhen(custom criteria)<br>
        <br>
        Caution: Do not use retry for authentication requests or risk blocking user account
    </p>
    <aside class="notes">
        Do not retry authentication requests, since these should only be initiated by user action.
        We don't want to lock out user accounts with repeated login requests that the user has not initiated.
    </aside>
</section>
<section>
    <h2>Übung</h2>
    <p>
        Eine Schnittstelle gibt natürliche Zahlen in aufsteigender Reihenfolge zurück.<br>
        Summiere die Potenz der ersten 3 geraden Zahlen und gibt das Ergebnis aus.
    </p>
    <aside class="notes">
        Siehe zusätzliche Operatoren: <code>reduce()</code> und <code>take()</code>
    </aside>
</section>
<section>
    <h2>Quellen</h2>
    <ul>
        <li>https://de.wikipedia.org/wiki/Reaktive_Programmierung</li>
        <li>https://rxjs-dev.firebaseapp.com/</li>
        <li>https://angular.io/guide/rx-library</li>
        <li>https://www.learnrxjs.io/</li>
    </ul>
</section>