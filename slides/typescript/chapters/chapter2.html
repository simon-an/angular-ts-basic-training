<!-- <aside style="position: absolute; top: 0px; right: 0px;" data-controls-layout>Typescript Handy On</aside> -->
<section>
    <h1>TypeScript Basics</h1>
</section>
<section>
    <h2>Exercise 1 & 2</h2>
    <p>Setup TypeScript and your first TypeScript project</p>
    <aside class="notes">
        Show package.json<br>
        package.json corresponds to pom.xml of maven<br>
        node_modules corresponds to .m2 folder of maven<br>
        Show tsconfig.json: show targe says es5 and module says es2015 as result targets
    </aside>
</section>
</section>
<section>
    <h2>Basic Types</h2>
    <h4>Boolean</h4>
    <pre><code>let isDone: boolean = false;</code></pre>
    <h4>Number</h4>
    <pre><code  class="typescript" data-trim data-noescape>
        let decimal: number = 6; 
        let hex: number = 0xf00d; 
        let binary: number = 0b1010; 
        let octal: number = 0o744;
    </code></pre>
    <h4>String</h4>
    <pre><code class="typescript" data-trim data-noescape>
        let color: string = "blue";
        color = 'red';
        let age: number = 37;
        let sentence: string = `Hello, my name is ${ fullName }.
        I'll be ${ age + 1 } years old next month.`;
    </code></pre>
</section>
<section>
    <h4>Array</h4>
    <pre><code>let list: number[] = [1, 2, 3];</code></pre>
    <pre><code class="typescript">let list: Array&lt;number> = [1, 2, 3];</code></pre>
    <h4>Tuple</h4>
    <pre><code data-trim data-noescape>
        let x: [string, number];
        // Initialize it
        x = ["hello", 10]; // OK
        // Initialize it incorrectly
        x = [10, "hello"]; // Error
    </code></pre>
    <h4>Enum</h4>
    <pre><code data-trim data-noescape>
        enum Color {Red, Green, Blue}
        let c: Color = Color.Green;
    </code></pre>
</section>
<section>
    <h4>Any</h4>
    <pre><code class="typescript" data-trim data-noescape>
        let list: any[] = [1, true, "free"];
    </code></pre>
    <h4>Unkown</h4>
    <pre><code class="typescript" data-trim data-noescape>
        let someValue: unknown = "this is a string";
        let someValue: unknown = 999;
        if (typeof someValue === 'string') {
            let strLength: number = (&lt;string>someValue).length;
        } else {
            console.error('wrong type');
        }
    </code></pre>
</section>
<section>
    <h4>Void</h4>
    <pre><code class="typescript" data-trim data-noescape>
        function warnUser(): void {
            console.log("This is my warning message");
        }
    </code></pre>
    <h4>Never</h4>
    <pre><code class="typescript" data-trim data-noescape>
        function error(message: string): never {
            throw new Error(message);
        }
        function blockthread(message: string): never {
            while(true){
                
            }
        }
    </code></pre>
</section>
<section>
    <h4>Undefined, Null</h4>
    <pre><code class="typescript" data-trim data-noescape>
        function doSomething(param: string | null | undefined): void
    </code></pre>
    <h4>Object</h4>
    <p>Object ist ein nicht primitiver Typ, also alles was nicht number, string, boolean,
        symbol, null, oder undefined ist.</p>
    <pre><code class="typescript" data-trim data-noescape>
        function create(o: object | null): void;
    </code></pre>
    <pre><code class="typescript" data-trim data-noescape>
        function create(o: {} | null): void;
    </code></pre>
</section>
<section>
    <h2>Type Assertions</h2>
    <pre><code>let strLength: number = (&lt;string>someValue).length;</code></pre>
    <pre><code>let strLength: number = (someValue as string).length;</code></pre>
</section>
<section>
    <h2>Undefined & null Prüfung</h2>
    <pre><code class="typescript" data-trim data-noescape>
        function nullcheck(param: { property: string }) {
            if(param !== null && typeof param !== 'undefined'){
                if(param.property !== null && 
                    typeof param.property !== 'undefined'){
                        // NOOOOO
                }
            }
            if(param && param.property){
                // string
            }
            if(!!(param && param.property)){
                // boolean
            }
        }
    </code></pre>
    <p>!! Operator: "bang, bang you're boolean" </p>
</section>
<section>
    <h2>Variable Declarations</h2>
    <pre><code>var a = 10;</code></pre>
    <pre><code data-trim data-noescape>
        const b = 'hello';
        b += 'world'; // error
    </code></pre>
    <p>var scoping</p>
    <pre><code data-trim data-noescape>
        function f(shouldInitialize: boolean) {
            var x;
            if (shouldInitialize) {
                x = 10;
            }
            return x;
        }
        console.log(f(true)); // returns '10'
        console.log(f(false)); // returns 'undefined'                          
    </code></pre>
    <pre><code>f(true);  // returns '10'</code></pre>
    <pre><code>f(false); // returns 'undefined'</code></pre>
</section>
<section>
    <h4>const</h4>
    <p>const sorgt <b>nicht</b> für Immutablitity</p>
    <pre><code data-trim data-noescape>
        const numLivesForCat = 9;
        const kitty = {
            name: "Aurora",
            numLives: numLivesForCat,
        }
        kitty = {// Error
            name: "Danielle",
            numLives: numLivesForCat
        };
        // all "okay"
        kitty.name = "Rory";
        kitty.name = "Kitty";
        kitty.name = "Cat";
        kitty.numLives--;
    </code></pre>
    <aside class="notes">
        const is like final in JAVA.
    </aside>
</section>
<section>
    <p>Wo ist der Fehler?</p>
    <pre><code data-trim data-noescape>
        function sumMatrix(matrix: number[][]) {
            var sum = 0;
            for (var i = 0; i &lt; matrix.length; i++) {
                var currentRow = matrix[i];
                for (var i = 0; i &lt; currentRow.length; i++) {
                    sum += currentRow[i];
                }
            }
            return sum;
        }
    </code></pre>
    <p class="fragement">Use let instead var for i.</p>
</section>
<section>
    <p>Was ist das Ergebnis auf der Console?</p>
    <pre><code class="typescript" data-trim data-noescape>
        for (var i = 0; i &lt; 10; i++) {
            setTimeout(function() { console.log(i); }, 100 * i);
        }
    </code></pre>
</section>
<section>
    <h2>Destructing Arrays</h2>
    <pre><code class="typescript" data-trim data-noescape>
        let [first, ...rest] = [1, 2, 3, 4];
        console.log(first); // outputs 1
        console.log(rest); // outputs [ 2, 3, 4 ]
    </code></pre>
    <h2>Destructing Objects</h2>
    <pre><code class="typescript" data-trim data-noescape>
        let o = {
            a: "foo",
            b: 12,
            c: "bar"
        };
        let { a, b } = o;
    </code></pre>
</section>
<section>
    <h2>Spread Operator</h2>
    <pre><code class="typescript" data-trim data-noescape>
        let first = [1, 2];
        let second = [3, 4];
        let bothPlus = [0, ...first, ...second, 5];
    </code></pre>
</section>
<section>
    <h2>Interfaces</h2>
    <p>Explizit definierte Typen</p>
    <pre><code data-trim data-noescape class="typescript">
        function printLabel(labelledObj: { label: string }) {
            console.log(labelledObj.label);
        }
        let myObj = {size: 10, label: "Size 10 Object"};
        printLabel(myObj);
    </code></pre>
    <pre><code data-trim data-noescape class="typescript">
        interface LabelledValue {
            label: string;
            readonly optional?: boolean;
        }
        
        function printLabel(labelledObj: LabelledValue) {
            console.log(labelledObj.label);
        }
        let myObj = {size: 10, label: "Size 10 Object"};
        printLabel(myObj);
    </code></pre>
    <p>Was macht der Compiler mit Interfaces?</p>
</section>
<section>
    <h2>Readonly</h2>
    <ul>
        <li>Variables: const</li>
        <li>Properties: readonly</li>
        <li>ReadonlyArray:</li>
    </ul>
    <pre><code class="typescript" data-trim data-noescape>
        let a: number[] = [1, 2, 3, 4];
        let ro: ReadonlyArray&lt;number> = a;
        ro[0] = 12; // error!
        ro.push(5); // error!
        ro.length = 100; // error!
        a = ro; // error!
    </code></pre>
</section>
<section>
    <h2>Klassen</h2>
    <p>Constructor Parameter werden automatisch zu Properties, mit einem Zugriffsmodifier oder readonly.</p>
    <pre><code class="typescript" data-trim data-noescape>
        class DigitalClock implements ClockInterface {
            constructor(public h: number, public m: number) {}
            tick() {
                console.log('beep beep');
            }
        }
    </code></pre>
    <pre><code class="typescript" data-trim data-noescape>
            get fullName(): string {
                return this._fullName;
            }
            set fullName(newName: string) {
                if (passcode && passcode == "secret passcode") {
                    this._fullName = newName;
                }
            }
            employee.fullName = "Bob Smith";
            console.log(employee.fullName);
        </code></pre>
</section>
<section>
    <h2>Funktionen</h2>
    <p>Unterschied zu JS: Signatur.</p>
    <pre><code class="typescript" data-trim data-noescape>
        let myAdd0: (x: number, y: number) => number = (x, y) => {
            return x + y;
        };

        function myAdd1(x: number, y: number): number {
            return x + y;
        }
        type functionType = (x: number, y: number) => number;
        let myAdd2: functionType = (x, y) => {
            return x + y;
        };
    </code></pre>
    <aside class="notes">
        First is not so good because it is badly readable and the definition of the signature is not reusable. Second and third example are good.
    </aside>
</section>
<section>
    <p>Optional Parameter:</p>
    <pre><code class="typescript" data-trim data-noescape>
        function buildName(firstName: string, lastName?: string) {}
    </code></pre>
    <p>Default Parameter:</p>
    <pre><code class="typescript" data-trim data-noescape>
        function buildName(firstName: string, lastName = 'Smith') {}
    </code></pre>
    <p>Rest Parameter:</p>
    <pre><code class="typescript" data-trim data-noescape>
        function buildName(firstName: string, ...restOfName: string[]) {}
    </code></pre>
</section>
<section>
    <h2>this and arrow functions</h2>
    <p>In JavaScript ist <i>this</i> eine Variable, die gesetzt wird, wenn eine Funktion aufgerufen wird. </p>
    <p>Arrow Funktionen setzen <i>this</i> dort, wo die Funktion erzeugt wird.</p>
</section>
<section>
    <h2>Generics</h2>
    <p>Function Signature</p>
    <pre><code class="typescript" data-trim data-noescape>
        function create&lt;T>(c: {new(): T; }): T {}
    </code></pre>
    <p>Function Signature</p>
    <pre><code class="typescript" data-trim data-noescape>
        function getProperty&lt;T, K extends keyof T>(obj: T, key: K) {}
    </code></pre>
    <p>Generic Classes</p>
    <pre><code class="typescript" data-trim data-noescape>
        class GenericNumber&lt;T> {
            zeroValue: T;
            add: (x: T, y: T) => T;
        }
    </code></pre>
</section>
<section>
    <h2>Enums</h2>
    <p>Numeric Enums</p>
    <pre><code class="typescript" data-trim data-noescape>
    enum Direction {
        Up = 1,
        Down,
        Left,
        Right,
    }
    </code></pre>
    <p>String Enums</p>
    <pre><code class="typescript" data-trim data-noescape>
        enum Direction {
            Up = "UP",
            Down = "DOWN",
            Left = "LEFT",
            Right = "RIGHT",
        }
    </code></pre>
</section>
<section>
    <h2>Type Inference</h2>
    <p>Best common type</p>
    <pre><code>let x = [0, 1, null];</code></pre>
    <pre><code>number | null</code></pre>
    <p>Contextual Type</p>
    <pre><code class="typescript" data-trim data-noescape>
        function createZoo(): Animal[] {
            return [new Rhino(), new Elephant(), new Snake()];
        }
    </code></pre>
    <pre><code>Animal</code></pre>
</section>
<section>
    <h2>Type Compatibility (1)</h2>
    <p>Type compatibility in TypeScript is based on structural subtyping. Structural typing is a way of relating types
        based solely on their members. This is in contrast with nominal typing. Consider the following code:</p>
    <pre><code class="typescript" data-trim data-noescape>
        interface Named {
            name: string;
        }
    
        class Person {
            name: string;
        }
        let p: Named;
        // OK, because of structural typing
        p = new Person();",
        }
    </code></pre>
</section>
<section>
    <h2>Type Compatibility (2)</h2>
    <pre><code class="typescript" data-trim data-noescape>
        let x = (a: number) => 0;
        let y = (b: number, s: string) => 0;
        
        y = x; // OK
        x = y; // Error
    </code></pre>
</section>
<section>
    <h2>Advanced Types</h2>
    <p>Intersection</p>
    <pre><code class="typescript" data-trim data-noescape>
        function extend&lt;T, U>(first: T, second: U): T & U {}
    </code></pre>
    <p>Union Types</p>
    <pre><code class="typescript" data-trim data-noescape>
        function padLeft(value: string, padding: string | number) {}
    </code></pre>
    <p>Type Guards</p>
    <pre><code class="typescript" data-trim data-noescape>
    function isFish(pet: Fish | Bird): pet is Fish {
        return (&lt;Fish>pet).swim !== undefined;
    }
    </code></pre>
</section>
<section>
    <h2>Iterators und Generators</h2>
    <p>values: for..of (Iterator Types. Unterschiedlicher Compiler-Output mit ES3 und ES5)</p>
    <p>keys: for..in Objects und Iterator Types</p>
    <pre><code class="typescript" data-trim data-noescape>
    const list4to6 = ["4", "5", "6"];
    for (let i in list4to6) {
        console.log(i); // "0", "1", "2" (index)
    }
    for (let i of list4to6) {
        console.log(i); // "4", "5", "6" (items)
    }
    </code></pre>
</section>
<section>
    <h2>Namespaces</h2>
    <p>Ähnlich zu packages in Java oder C++.</p>
    <pre><code class="typescript" data-trim data-noescape>
        namespace Shapes {
            export namespace Polygons {
                export class Triangle { }
                export class Square { }
            }
        }
        import polygons = Shapes.Polygons;
        let sq = new polygons.Square();
        // Same as 'new Shapes.Polygons.Square()
    </code></pre>
</section>
<section>
    <h2>Declaration Merging</h2>
    <pre><code class="typescript" data-trim data-noescape>
    interface Box {
        height: number;
        width: number;
    }
    
    interface Box {
        scale: number;
    }
    
    let box: Box = {height: 5, width: 6, scale: 10};
</code></pre>
</section>
<section>
    <h2>Map</h2>
    <pre><code data-trim data-noescape class="typescript">
    const resultArray = [];
    const initialArray = [1, 2, 3, 4];
    for (let index = 0; index &lt; initialArray.length; index++) {
        resultArray[index] = initialArray[index] * initialArray[index];
    }
    </code></pre>
    <pre><code data-trim data-noescape class="typescript">
    const multiply = (value: number) => value * value;
    console.log([1, 2, 3, 4].map(multiply));
    </code></pre>
</section>
<section>
    <h2>Filter</h2>
    <pre><code data-trim data-noescape style="font-size: 20px" class="typescript">
        const initialArray = [1, 2, 3, 4];
        for (let index = 0; index &lt; initialArray.length; index++) {
            if (initialArray[index] * 100 > 200) {
                resultArray.push(initialArray[index] * 100);
                // resultArray[index] = initialArray[index] * 100;
            }
        }
    </code></pre>
    <pre><code data-trim data-noescape style="font-size: 20px" class="typescript">
        console.log([1, 2, 3, 4].map(num => num * 100).filter(value => value > 200));
    </code></pre>
</section>
<section>
    <h2>Reduce</h2>
    <pre><code data-trim data-noescape class="typescript">
    let result = 0;
    [1, 2, 3, 4].forEach(number => result += number);
    </code></pre>
    <pre><code data-trim data-noescape class="typescript">
    // Pure Function
    const reducer = (sum: number, value: number) => sum += value;
    console.log([1, 2, 3, 4].reduce(reducer, 0));
    </code></pre>
</section>